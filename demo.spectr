
f: int -> int -> int
f(5i) 6i + 7i

#[x: int = (5i + 4i) * 4i
y := 5i

option: int | str

nothing: void = nil

func: int -> int = (arg: int) -> arg

eval: (int -> int, int) -> int = (f, i) -> f i
eval (func, 5i)

curry: ((int -> int, int) -> int) -> ((int -> int) -> int -> int) = unseasoned -> f -> i -> unseasoned (f, i)
(curry eval) func 5i

infCurry := (unseasoned: (int -> int, int) -> int) -> (f: int -> int) -> (i: int) -> unseasoned (f, i)
(infCurry eval) func 5i

constant: () -> int = () -> 5i

constant

constant()

test: any = 5i
test]#

#[
[
    name := "Paul"
    return name

    if true [
        return 5i
    ]
    elif false [
        name
    ]
]


add: (int, int) -> int = (a, b) -> a + b
]#

#[
add5: (int) -> int = a -> [
    return a + "Hallo"
]

eval: (int -> int) -> (int -> int)

#f: (int -> int) -> int = a -> 0i

fun function(input: int | str) -> str [
    
]


type Foo [
    name: str
    action: Foo @ () -> void
    n: int = 3i
    fun method() [
        return this.action()
    ]
]

x := Foo()

x.action()

do: Foo -> Foo = (f) -> f
(do x).action()

myMethod: Foo @ (int) -> int = (a) -> [
    return a + this.n
]

(x @ myMethod)(0i)
(y @ myMethod)(0i)

f: int -> int = x @ myMethod
f(0) #3
x.n += 1
f(0) #4

y.action = x @ myMethod

y.action()

type Bar : Foo [
    fun method() [
        print("Hallo")
        return super.method()
    ]
]

type Container(T, S) [
    obj: T
    transform: S -> T
]

intContainer: Container(int)

list: {int} = {4i, 5i}
list{1i} #5i

tuple: (int, str, bool) = (5i, "Hallo", true)

t: (int, str)*(str, bool) #(int, str, str, bool)

arr: int**5i

n: int
tuple{1i} # str

type List(T) = {T}

List:: type => type = T => {T}
WrapTwice:: (type => type) => (type => type) = Wrapper => (T => Wrapper(Wrapper(T)))

Array:: (type, int) => type = (T, n) => T**n

arr: Array(int, 5i)

(WrapTwice(List))(int) # List(List(int))

fact: int -> int
fact n = n * fact (n-1)
fact 0 = 1

]#